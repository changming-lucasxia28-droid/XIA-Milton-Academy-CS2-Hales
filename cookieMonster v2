public class Main {

    int rows = 30; // Number of rows
    int cols = rows; // Number of columns. its same as rows because we want a square
    int bestPath = 99999999; //current best path. we make it massive so that the first path will auto be the new best path
    String Superpaths = ""; //this exists just to pull the best path out of "move" and so that we can print it
    int[][] array = new int[rows][cols];
    public static void main(String[] args) {

        System.out.println("Here is the grid:");
        Main app;
        app= new Main();
    }
    public Main(){
        make();
        print();
        move(0,0, 0, "Path Used: ");
        // there three (below) are here so that we just print the best one possible
        System.out.println(bestPath);
        System.out.println(Superpaths);
        System.out.println("I am home!");
    }
    public void make(){
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                //System.out.println("I= "+i+ "J= "+j);
                array[i][j] = (int)(Math.random()*100) + 1;
            }
        }
    }
    public void print(){
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.print(array[i][j] + "\t");
            }
            System.out.println();
        }
    }
    public void move(int x,int y, int localSum, String paths) {
        //System.out.println(array[x][y]);
        localSum = array[x][y] + localSum; //this stores the last path walked

        if (x == rows - 1 && y == cols - 1) {
            if (localSum < bestPath) { //if the last path walked is better than the current best path
                bestPath = localSum; //place the best path with the last walked one
                Superpaths = paths; //Superpath will just make it so that its accessible to more than the move class

            }
        } else {
            if (localSum < bestPath) {
                if (x < rows - 1 && y < cols - 1) {
                    move(x + 1, y + 1, localSum, paths + "Diagonal "); //diagonal
                }
                if (y < cols - 1) {
                    move(x, y + 1, localSum, paths + "Down "); //down
                }
                if (x < rows - 1) {
                    move(x + 1, y, localSum, paths + "Right "); //right
                }
            }

        }
    }
}
